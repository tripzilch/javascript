<!doctype html><html>
<head>
  <meta charset="utf-8">
  <title>LETTUCE TRACE</title>
  <style>*{margin:0;padding:0;}
    body {
      background: #000;
    }
    canvas{
      display: block;
      margin: 4px auto;
      width: 1200px;
      height: 600px;
    }
    textarea {
      display: block;
      margin: 4px auto;
      width: 1200px;
      height: 50px;      
      background: #000;
      color: #666;
      border: 1px solid #333;
    }

  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <textarea id="txt"></textarea>
  <script src="math.js"></script>
  <script>
    'use strict';
    let canvas = document.getElementById("c");
    let txt = document.getElementById("txt");
    const oversample = 1;
    const W = 1200 * oversample,
          H = 600 * oversample;
    canvas.width = W;
    canvas.height = H;

    let canvas_rect = canvas.getBoundingClientRect();

    let [mouse_x, mouse_y] = [0, 0];
    canvas.addEventListener('mousemove', ev => {
      [mouse_x, mouse_y] = [ev.clientX - canvas_rect.left, ev.clientY - canvas_rect.top];
    }, false);

    let keys = [];
    window.addEventListener("keydown", ev => { keys[ev.keyCode] = true; });
    window.addEventListener("keyup", ev => { keys[ev.keyCode] = false; });

    function clear(ctx, c='#fff') { ctx.fillStyle = c; ctx.fillRect(0, 0, W, H); }
    //function clear(ctx, c='#fff') { ctx.fillStyle = c; ctx.fillRect(-W/2, -H/2, W/2, H/2); }
    function circle(ctx, x, y, r) { ctx.moveTo(x + r, y); ctx.arc(x, y, r, 0, TAU); }

    function linear_curve(ctx, vv) {
      ctx.moveTo(vv[0].x, vv[0].y)
      for (let i = 1; i < vv.length; i++) { ctx.lineTo(vv[i].x, vv[i].y); }
      return vv;
    }

    function quadratic_curve(ctx, vv) { /*
      https://stackoverflow.com/a/7058606 -- The problem with joining subsequent sample points together with disjoint "curveTo" type functions, is that where the curves meet is not smooth. This is because the two curves share an end point but are influenced by disjoint control points. One solution is to "curve to" the midpoints between the next 2 subsequent sample points. Joining the curves using these new interpolated points gives a smooth transition at the end points. What is an end point for one iteration becomes a control point for the next iteration. Note: this solution does not actually draw through each of the points. There is a solution to go through all the sample points, but it is much more complicated (see http://www.cartogrammar.com/blog/actionscript-curves-update/)
      */
      ctx.moveTo(vv[0].x, vv[0].y)
      for (let i = 1; i < vv.length - 2; i++) {
        let vi = vv[i];
        let vc = vi.xy.mix(vv[i + 1], .5);
        ctx.quadraticCurveTo(vi.x, vi.y, vc.x, vc.y);
      }
      ctx.quadraticCurveTo(vv[i].x, vv[i].y, vv[i + 1].x,vv[i + 1].y);
      return vv;
    }

    function smooth_path(ctx, pp) {
      let sp = [];
      for (let i = 1; i < pp.length; i++) {
        sp.push(pp[i].xy.mix(pp[i - 1], .5));
      }
      return sp;
    }

    function stroke_path_smooth(ctx, pp) {
      ctx.beginPath();
      linear_curve(ctx, smooth_path(pp));
      ctx.stroke();
    }

    function thick_brush(ctx, pp, ww) {
      // draw a stroke/brush along points pp with thickness ww

      //// construct both sides of stroke
      let s1 = [], s2 = [];
      let prev, [cur, next] = [pp[0], pp[1]];
      for (let i = 2; i < pp.length; i++) {
        [prev, cur, next] = [cur, next, pp[i]];
        let n = next.xy.sub(prev).normalize().rot90();
        let w = ww[i];
        s1.push(cur.xy.madd(n, w));
        s2.push(cur.xy.madd(n, -w));
      }

      // combine
      s2.reverse();
      let ss = s1.concat(s2);

      // experimental: dither
      // for (let s of ss) { s.x += (rand()-rand())/oversample; s.y += (rand()-rand())/oversample; }

      // draw
      ctx.beginPath();
      linear_curve(ctx, ss);
      ctx.closePath();
      ctx.fill();
      //ctx.stroke(); // for debug: I don't plan to stroke strokes
    }


    const c_spring = 0.05;  // kg/s^2 or N/m
    const c_drag = 0.02; // 1/s ??
    const c_repulsion = 1 / 0.0025; // 1/m, distance of unity repulsion force (beyond which it gets big fast)
    const c_density = 1000.0; // water, kg/m^3
    class Sim {
      constructor(dt=.001) {  // time in seconds
        this.t = 0;
        this.dt = dt;
        this.nodes = [];
        this.grid = new Grid(.08); // cell size 8 cm
      }
      // don't prematurely optimize, write the pretty code that works
      step(n) {
        // iterate for steps of min_dt
        for (let i = 0; i < n; i++) {
          // leapfrog integration
          // x += v * dt
          this.grid.clear();
          for (let p of this.nodes) {
            p.x += p.vx * this.dt; 
            p.y += p.vy * this.dt; 
            // add to spatial map            
            this.grid.add(p);
          }
          // a = F(x)
          this.derive_a();
          // v += a * dt
          for (let p of this.nodes) {
            p.vx += p.ax * this.dt; 
            p.vy += p.ay * this.dt;
          }
          this.t += this.dt
        }
      }

      derive_a() {
        for (let p of this.nodes) {
          let Fx = 0, Fy = 0;
          // spring forces between neighbours
          for (let q of p.nn) {
            let dx = q.x - p.x, dy = q.y - p.y;
            let d = Math.hypot(dx, dy);
            // F = -kx
            let F = -c_spring * (p.r + q.r - d);            
            Fx += F * dx / d;
            Fy += F * dy / d;
          }
          // nearby repulsion forces
          const eps = 1E-9;
          for (let q of this.grid.query(p.x, p.y)) {
            if (p === q) continue;
            let dx = q.x - p.x, dy = q.y - p.y;
            let d = Math.max(eps, Math.hypot(dx, dy));
            if (d < this.grid.R) {
              let F = -Math.pow(d * c_repulsion, -2);
              Fx += F * dx;
              Fy += F * dy;
            }
          }
          // drag
          Fx -= c_drag * p.vx;
          Fy -= c_drag * p.vy;
          // F = m * a, a = F / m
          p.ax = Fx / p.m;
          p.ay = Fy / p.m;
        }
      }

      draw(ctx) {
        for (let p of this.nodes) p.draw(ctx);
      }
    }

    class Grid {
      constructor(R) {
        this.R = R;
        this.Rinv = 1 / R;
        this.grid = {};
      }

      add(p) {
        let i = [Math.floor(this.Rinv * p.x), Math.floor(this.Rinv * p.y)];
        if (!this.grid[i]) this.grid[i] = [];
        this.grid[i].push(p);
      }

      query(x, y) { 
        let rx = this.Rinv * x;
        let ry = this.Rinv * y;
        let cell = (x, y) => (this.grid[[Math.floor(x), Math.floor(y)]] || []);
        return Array.concat(cell(rx - 0.5, ry - 0.5), cell(rx + 0.5, ry - 0.5),
                            cell(rx - 0.5, ry + 0.5), cell(rx + 0.5, ry + 0.5));
      }

      clear() {
        this.grid = {};
      }
    }

    let current_id = 0;
    class Node {
      constructor(x, y, r=.01, vx=0, vy=0) { // default 1cm size
        this.id = current_id++;
        this.x = x;  // m
        this.y = y;
        this.vx = vx;  // m/s
        this.vy = vy;
        this.ax = this.ay = 0; // m/s^2
        this.r = r; // m
        this.nn = []; // neighbours
      }

      connect(other) {
        this.nn.push(other);
        other.nn.push(this);
      }

      draw(ctx) {        
        circle(ctx, this.x, this.y, this.r);
        circle(ctx, this.x, this.y, this.r * 0.75);
        circle(ctx, this.x, this.y, this.r * 0.625);
        for (let other of this.nn) {
          if (this.id > other.id) { // only draw edge once
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(other.x, other.y);
          }
        }
      }

      // getset
      get m() { return c_density * 0.01 * this.r * this.r * PI; } // kg (1cm high disc)

      // nonsense
      get xy() { return [this.x, this.y]; }
      set xy(v) { [this.x, this.y] = [v.x, v.y]; }

      // static initializers
      static random(a=1) { // probably a bad idea
        return new Node(a * (RNG() - .5), a * (RNG() - .5));
      }
    }    

    let t0 = Date.now();
    let sim = new Sim();
    for (let i = 0; i < 40; i++) {
      sim.nodes.push(new Node((i - 20) * .010, nrand() * .05, .01));
      if (i > 0) sim.nodes[i].connect(sim.nodes[i - 1]);
    }
    sim.nodes[20].r = .02;
    let frame_count = 0;
    let running = true;
    let now = t0;
    function draw() {
      if (!running) return;
      frame_count ++;
      let prev_now = now;
      now = Date.now() - t0;
      let dt = now - prev_now;
      sim.step(50); 
      clear(ctx, '#eee');
      ctx.save();
      ctx.translate(W/2, H/2);      
      ctx.scale(oversample, oversample);
      let S = 1000; // 1mm = 1px
      ctx.scale(S, S); // 1mm = 1px
      ctx.strokeStyle = '#002';
      ctx.lineWidth = .5 / S; // 0.5 mm
      ctx.beginPath();
      sim.draw(ctx);
      ctx.stroke();
      ctx.restore();
      window.requestAnimationFrame(draw);
    }

    let ctx = canvas.getContext("2d");
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    clear(ctx, '#232425');
    draw();
    window.addEventListener("keydown", ev => { 
      if (ev.key === " ") { 
        running = !running;
        if (running) draw();
      }
    });

  </script>
</body>

</html>
