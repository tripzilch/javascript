<!doctype html><html>
<head>
  <meta charset="utf-8">
  <title>LEDGETRACE</title>
  <style>*{margin:0;padding:0;}
    body {
      background: #000;
    }
    canvas{
      display: block;
      margin: 4px auto;
      width: 1200px;
      height: 600px;
    }
  </style>
</head>

<body>
  <canvas id="c"></canvas>
  <script>
    'use strict';
    let canvas = document.getElementById("c");
    const oversample = 1;
    const W = 1200 * oversample,
          H = 600 * oversample;
    canvas.width = W;
    canvas.height = H;
    let canvas_rect = canvas.getBoundingClientRect();

    let [mouse_x, mouse_y] = [0, 0];
    canvas.addEventListener('mousemove', ev => {
      [mouse_x, mouse_y] = [ev.clientX - canvas_rect.left, ev.clientY - canvas_rect.top];
    }, false);

    let keys = [];
    window.addEventListener("keydown", ev => { keys[ev.keyCode] = true; });
    window.addEventListener("keyup", ev => { keys[ev.keyCode] = false; });

    const PI = Math.PI, TAU = PI * 2;
    // let sin = Math.sin, cos = Math.cos, tan = Math.tan, Math.random = Math.random, Math.floor = Math.floor;
    // let Math.max = Math.max, Math.min = Math.min, sqrt = Math.sqrt, hypot = Math.hypot, abs = Math.abs;
    let mix = (a, b, p) => a * (1 - p) + b * p;
    let clamp = (x, lo, hi) => Math.min(hi, Math.max(lo, x));
    let rand = (lo, hi) => lo + ((hi - lo) * Math.random());
    let irand = (lo, hi) => Math.floor(lo + ((hi - lo) * Math.random()));
    let nrand = () => Math.random() - Math.random();
    let sample = (a) => a[irand(0, a.length)];
    let wrap = (a, n) => (a + n) % n;
    let pmod = (a, b) => (a % b + b) % b;
    let smoothstep = (x, e0, e1) => {
      x = clamp((x - e0) / (e1 - e0), 0, 1);
      return x * x * (3 - 2 * x);
    }
    class Vec2 {
      constructor(x, y) {
        this.x = x;
        this.y = y;
      }
      // vector update methods
      add(v) { this.x += v.x; this.y += v.y; return this; }
      sub(v) { this.x -= v.x; this.y -= v.y; return this; }
      mul(v) { this.x *= v.x; this.y *= v.y; return this; }
      madd(v, a) { this.x += v.x * a; this.y += v.y * a; return this; }
      mix(v, p) { this.x += (v.x - this.x) * p; this.y += (v.y - this.y) * p; return this; }
      rot90() { [this.x, this.y] = [-this.y, this.x]; return this; }
      rot180() { this.x *= -1; this.y *= -1; return this; }
      rot270() { [this.x, this.y] = [this.y, -this.x]; return this; }
      normalize() { let h = 1 / Math.hypot(this.x, this.y); this.x *= h; this.y *= h; return this; }
      op1(f) { this.x = f(this.x); this.y = f(this.y); return this; }
      op2(v, f) { this.x = f(this.x, v.x); this.y = f(this.y, v.y); return this; }
      op3(v, w, f) { this.x = f(this.x, v.x, w.x); this.y = f(this.y, v.y, w.y); return this; }

      // scalar methods
      dist(v) { return Math.hypot(this.x - v.x, this.y - v.y); }
      hypot() { return Math.hypot(this.x, this.y); }

      // swizzling
      get xy() { return new Vec2(this.x, this.y); } // also copy
      get yx() { return new Vec2(this.y, this.x); }
      get xx() { return new Vec2(this.x, this.x); }
      get yy() { return new Vec2(this.y, this.y); }
      set xy(v) { [this.x, this.y] = [v.x, v.y]; }
      set yx(v) { [this.x, this.y] = [v.y, v.x]; }

      // static initializers
      static random(a=1, rng=Math.random) {
        return new Vec2(a * rng(), a * rng());
      }

    }

    function clear(ctx, c='#fff') { ctx.fillStyle = c; ctx.fillRect(0, 0, W, H); }

    function linear_curve(ctx, vv) {
      ctx.moveTo(vv[0].x, vv[0].y)
      for (var i = 1; i < vv.length; i++) { ctx.lineTo(vv[i].x, vv[i].y); }
      return vv;
    }

    function quadratic_curve(ctx, vv) { /*
      https://stackoverflow.com/a/7058606 -- The problem with joining subsequent sample points together with disjoint "curveTo" type functions, is that where the curves meet is not smooth. This is because the two curves share an end point but are influenced by disjoint control points. One solution is to "curve to" the midpoints between the next 2 subsequent sample points. Joining the curves using these new interpolated points gives a smooth transition at the end points. What is an end point for one iteration becomes a control point for the next iteration. Note: this solution does not actually draw through each of the points. There is a solution to go through all the sample points, but it is much more complicated (see http://www.cartogrammar.com/blog/actionscript-curves-update/)

        for (i = 1; i < points.length - 2; i ++) {
          var xc = (points[i].x + points[i + 1].x) / 2;
          var yc = (points[i].y + points[i + 1].y) / 2;
          ctx.quadraticCurveTo(points[i].x, points[i].y, xc, yc);
        }
        ctx.quadraticCurveTo(points[i].x, points[i].y, points[i+1].x,points[i+1].y);    */
      ctx.moveTo(vv[0].x, vv[0].y)
      for (var i = 1; i < vv.length - 2; i++) {
        let vi = vv[i];
        let vc = vi.xy.mix(vv[i + 1], .5);
        ctx.quadraticCurveTo(vi.x, vi.y, vc.x, vc.y);
      }
      ctx.quadraticCurveTo(vv[i].x, vv[i].y, vv[i + 1].x,vv[i + 1].y);
      return vv;
    }

    function smooth_path(ctx, pp) {
      let sp = [];
      for (var i = 1; i < pp.length; i++) {
        sp.push(pp[i].xy.mix(pp[i - 1], .5));
      }
      return sp;
    }

    function stroke_path_smooth(ctx, pp) {
      ctx.beginPath();
      linear_curve(ctx, smooth_path(pp));
      ctx.stroke();
    }

    function thick_brush(ctx, pp, ww) {
      // draw a stroke/brush along points pp with thickness ww

      // calculate normals
      let np = [];
      let i = 1;
      np.push(pp[i].xy.sub(pp[i - 1]).normalize().rot90());
      for (; i < pp.length - 1; i++) {
        np.push(pp[i + 1].xy.sub(pp[i - 1]).normalize().rot90());
      }
      np.push(pp[i].xy.sub(pp[i - 1]).normalize().rot90());

      // construct both sides of stroke
      let s1 = [], s2 = [];
      for (i = 0; i < pp.length; i++) {
        let p = pp[i], n = np[i], w = ww[i];
        s1.push(p.xy.madd(n, w));
        s2.push(p.xy.madd(n, -w));
      }
      // combine
      s2.reverse();
      let ss = s1.concat(s2);

      // draw
      ctx.beginPath();
      linear_curve(ctx, ss);
      ctx.closePath();
      ctx.fill();
      ctx.stroke(); // for debug: I don't plan to stroke strokes
    }

    var frame_count = 0;
    function draw() {
      if (keys[74]) frame_count--;
      if (keys[75]) frame_count++;
      clear(ctx, "#233");

      let f = frame_count * .02;
      let pp = [], ww = [];
      let t;
      for (t = 0; t < 3; t += .005) {
        let x = Math.sin(t + f * .07) * Math.cos(1 + t * 2 + f * .1) * 250;
        let y = Math.cos(t - f * .06) * Math.sin(2 + t * 2 - f * .13) * 250;
        let w = 2.0 + (1 + Math.sin(3 + t * 17)) * 3;
        w = 36 * smoothstep(Math.min(t, 3 - t), 0, 0.75)
        pp.push(new Vec2(x + W/2, y + H/2));
        ww.push(w);
      }

      ctx.fillStyle = "#c62";
      ctx.strokeStyle = "rgba(255,144,32,1.0)";
      ctx.lineWidth = 1.0;
      thick_brush(ctx, pp, ww);

      ctx.strokeStyle = "#831";
      ctx.beginPath();
      linear_curve(ctx, pp);
      ctx.stroke();

      window.requestAnimationFrame(draw);
    }

    let ctx = canvas.getContext("2d");
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';

    clear(ctx, '#000');
    draw();

    /***************** LEDGE STUFF ******************

    let DISTANCE = 70.0,
        LEN = 2000,
        STEP = 1.0,
        BEST_OF = 12;

    let ledge = new Array(H).fill(-DISTANCE * 10);
    ledge = ledge.map(e => rand(0.9, 1.1) * e);
    console.log(ledge);
    function fledge(y) {
      let yi = Math.floor(y);
      let yf = y - yi;
      return ledge[pmod(yi, H)] * (1 - yf) + ledge[pmod(yi + 1, H)] * yf;
    }
    function dledge(x, y) {
      let yi = Math.floor(y);
      let yf = y - yi;
      let dx1 = x - ledge[pmod(yi - 1, H)], dy1 = y - yi - 1, d1 = hypot(dx1, dy1);
      let dx2 = x - ledge[pmod(yi    , H)], dy2 = y - yi    , d2 = hypot(dx2, dy2);
      let dx3 = x - ledge[pmod(yi + 1, H)], dy3 = y - yi + 1, d3 = hypot(dx3, dy3);
      let [s1, s2, s3] = [[d1, dx1, dy1], [d2, dx2, dy2], [d3, dx3, dy3]];
      if (s1 < s2 && s1 < s3) return s1;
      if (s2 < s3) return s2;
      return s3;
    }
    function get_path(y, a=PI / 2) {
      let x = fledge(y) + DISTANCE;
      let pp = [];
      for (var i = 0; i < LEN; i++) {
        let [ermin, amin, xmin, ymin] = [99999, 0, 0, 0];
        let na = a;
        for (var k = 0; k < BEST_OF; k++) {
          // step Math.random angle
          na = a + 0.15 * nrand() * PI / 2;
          //na = Math.max(Math.min(na, PI), 0)
          let nx = x + STEP / tan(na);
          let ny = y + STEP;
          let nxa = x + 5 * STEP / tan(na);
          let nya = y + 5 * STEP;
          let [d, dx, dy] = dledge(nxa, nya); // lookahead distance to ledge
          let er = (d - DISTANCE) ** 2;
          if (er < ermin) [ermin, amin, xmin, ymin] = [er, na, nx, ny];
        }
        [x, y, a] = [xmin, ymin, amin];
        pp.push([x, y]);
      }
      return pp;
    }

    var frame_count = 0;
    function draw() {
      frame_count++;

      let pp = get_path(rand(0, H));
      // adjust ledge
      pp.forEach(([x, y]) => { // todo properly loop this for if STEP > 1 and just to be sure
        let yi = pmod(Math.floor(y), H);
        ledge[yi] = Math.max(ledge[yi], x);
      });
      // smoothen ledge
      var min_ledge = W * 4;
      for (var k = 0; k < 12; k++) {
        let ledge1 = new Array(H);
        for (var i = 0; i < H; i++) {
          let [a, b, c] = [ledge[pmod(i - 1, H)], ledge[i], ledge[pmod(i + 1, H)]];
          let d = Math.max(a, b, c);
          ledge1[i] = (a + b * 2 + c) / 4;
          min_ledge = Math.min(ledge1[i], min_ledge);
        }
        ledge = ledge1;
      }

      //let arcut = (ar, p) => ar.slice(Math.floor(ar.length * p), Math.floor(ar.length * (1-p)));

      let g = smoothstep(min_ledge, W * 0.1, W * 0.9);
      let c = Math.random() < g ? 1 : 0;
      aa = '1.0'; // irand(1, 30) / 100;
      ctx.strokeStyle = [
        'rgba( 56, 16,144, ' + aa + ')',
        'rgba(255,160, 24, ' + aa + ')'][c];
      ctx.lineWidth = 4;
      draw_path(ctx, pp);

      if (min_ledge <= W + DISTANCE) window.requestAnimationFrame(draw);
    }

      ******** END LEDGE STUFF **********************/

  </script>
</body>

</html>
